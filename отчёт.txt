Отчет.
Студент Спиидонов Дмитрий Вячеславович
Группа БПИ-214
Вариант 7
Условие задачи:
    Разработать программу, вычисляющую с помощью степенного ряда с точностью не хуже 0,05% значение функции sin (x) для заданного параметра x.
Задание выполнено с расчетом на оценку 8

На 4 балла:
    * В файлах main.c и func.c хранятся программы на языке C.
    * Получены ассемблерные программы(main.s и func.s) откомпилированная при помощи команды в командной строке:
        gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none main.c
	    и
	    gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none func.c
      В файлы main.s и func.s добавлены комментарии, поясняющие эквивалентное представление переменных в программе на C
    * В полученном ассемблерном коде не использовались макросы, поэтому удалять было нечего.
    * Итоговая ассемблерная программа откоплилирована и скомпонована командой
        gcc main.s func.s -lm -o s
      Программа на языке C откоплилирована и скомпонована командой
        gcc main.c func.c -lm -o c
    * Полное тестовое покрытие(так же представлено в файле tests.txt):
        input:
	0
	output:
	0

	input:
	3.1415926
	output:
	0.000021

	input:
	17
	output:
	-0.961382

	input:
	4.433629
	output:
	-0.961382

	input:
	6,283185307
	output:
	-0.279387

	input:
	5
	output:
	-0.958933

	input:
	2
	output:
	0.909296
    * Результат тестовых прогонов программы на C и Ассемблере хранится в фотографиях в папке /4
        
        
На 5 баллов:
    * Программа реализована с использованием функций с передачей данных через параметры
    * В функции random_input используются локальные переменные:
	    double a
	
      В функции file_input используются локальные переменные:
        FILE *input_file
        FILE *output_file
        double x
        double a
        double result
      
      В функции arg_input используются локальные переменные:
        double x
        double a
        double result
	
      В функции def_input используются локальные переменные:
        double x
        double a
        double result
      
      В функции func используются локальные переменные:
        double result
        double x_i
        double i
        
    * В полученные ассемблерные программы добавлены комментарии, описывающие передачу фактических парметров, перенос возвращаемого результата. Описана связь между параметрами языка C и регистрами(файлы main.s и func_n.s(см. п. на 6 баллов))
    

На 6 баллов:
    * В функции func(файл func_n.s) минимизировано количество обращений к памяти путем максимального использования регистров процессора, добавлены комментарии:
	double x      - xmm4
	double result -	xmm5
	double x_i    - xmm0
	double i      - xmm7
    * На тестовом покрытии измененная программа показала те же результаты, что и прошлые программы. Результат тестовых прогонов программы хранится в фотографии в папке /6
    * Размеры программы на ассемблере:
                    |     func.s       |      new_func.s
      --------------|------------------|----------------------
       объектный    |                  |
        файл        |   1472 байта     |      1392 байта
                    |    (func.o)      |     (new_func.o)      
      --------------|------------------|----------------------
       бинарный     |                  |
        файл        |   16664 байта    |      16 664 байта
     (file + main.s)|                  |                      
      --------------------------------------------------------
      
      Объектные файлы получены командами:
        gcc -c func.s -lm
        gcc -c new_func.s -lm
     Бинарные(исполняемые) файлы получены командами:
        gcc main.s func.s -lm
        gcc main.s new_func.s -lm


На 7 баллов:
    * Функция func хранится отдельно в файле func.c
    * Реализовано задание текстовых файлов для ввода и вывода (ключ -f)
    * Изменений произойти не могло, т.к. программа изначально была реализована данным способом
    * Изначально программа, написанная на Си, используюет функцию, хранящуюся в файле func.c, однако после компиляции файла в ассемблерный код(main.s) участок кода с функцией удален, в дальнейшем "импорт" будет происходить путем использованием команды:
        gcc main.s func_n.s(или func.s) -o res
    * Си файл преобразован в ассемблерный код командой
        gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none func.c
    * Запуск программы происходит из командой строки командой(при помощи ключа)
        ./res -f <имя файла 1> <имя файла 2>
    * Созданы и добавлены файлы, содержащие примеры из тестового покрытия(test1.txt, test2.txt, и т.д.)


На 8 баллов:
    * В программе(файл main.c) реализовано 4 возможных вида вводы числа:
        1) Через консоль(как в программе на 4 балла) - передача без аргументов
        2) Через файлы - первым аргументом идет флаг -f(или --file), вторым и третьим аргументами идут имена файлов, с которым будет работать программа(читать данные из первого файла и возвращать результат во второй)
        3) Через аргументы, переданные в командную строку - для этого достаточно вместо флагов сразу передать элемент - нужное число
        4) Через генератор случайных наборов данных - для этого в аргументы передается флаг -r(или --random)
    * Также добавлен ключ -h(или --help), который выдает список аргументов, которые может обрабатывать командная строка
    * Для реализации пункта 3 создана отдельная папка secondPart. Дальнейшая работа проходит в этой папке
    * Из файла main.c получен ассемблерный код(файл main.s) командой 
        gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none main.c
    * В полученном файле был добавлен импорт функции func и последнее использование функции func заменено на функцию func_O(функция из пункта на 6)
    * Полученная программа была скомпилирована в исполняемый файл и запущена. Результат работы представлен на фотографиях, которая хранится в папке /8_second
    * В итоге получилось так, что скорость работы оптимизированной функции не превышает по времени работу неоптимизированной функции(исключение - test 1, но, вероятнее всего, разница в нескольких сотых секундах, которые не видно при выводе на экран, т.к. выремя выводится в секундах)
